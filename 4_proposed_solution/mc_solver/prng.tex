\chapter{Bitpacked Basic--Event Sampling Kernels}
\label{ch:prng-kernels}

Monte Carlo simulations, probability evaluations, and other sampling-based procedures benefit greatly from efficient, high-quality \acrfull{rng}s. A large class of modern \acrshort{rng}s are known as \textit{counter-based \acrfull{prng}s}, because they use integer counters (e.g., 32-bit or 64-bit) along with a stateless transformation to produce random outputs. The \emph{Philox} family of counter-based \acrshort{prng}s is a well-known example, featuring fast generation, high period, and good statistical properties. In this section, we discuss the general principles of counter-based \acrshort{prng}s, explain how Philox fits into this paradigm, analyze its complexity, and present a concise pseudocode version of the \(\text{Philox }4\times32\text{-10}\) variant. Subsequently, we detail the bitpacking scheme used to reduce memory consumption when storing large numbers of Bernoulli samples.

A counter-based \acrshort{prng} maps a user-supplied \emph{counter} (plus, optionally, a \emph{key}) to a fixed-size block of random bits via a deterministic function. Formally, if 
\[
  \mathbf{x} \;=\; (x_1, x_2, \ldots, x_k)
\]
is a vector of one or more 32-bit or 64-bit counters, and 
\[
  \mathbf{k} \;=\; (k_1, k_2, \ldots, k_m)
\]
is a key vector, then a counter-based \acrshort{prng} defines a transformation 
\[
   \mathcal{F}(\mathbf{x}, \mathbf{k})
   \;=\;
   (\rho_1, \rho_2, \ldots, \rho_r),
\]
where each \(\rho_j\) is typically a 32-bit or 64-bit output. Different increments of the counter \(\mathbf{x}\) produce different pseudo-random outputs \(\rho_j\). The process is stateless in the sense that advancing the RNG amounts to incrementing the counter (e.g., \(\mathbf{x}\mapsto \mathbf{x} + 1\)).

Compared to recurrence-based \acrshort{rng}s such as linear congruential generators or the Mersenne Twister, counter-based methods offer more straightforward parallelization, reproducibility across multiple streams, and strong structural simplicity: no internal state must be updated or maintained. This is particularly valuable in distributed Monte Carlo simulations or \acrshort{gpu}-based sampling, where each thread or work-item can be assigned a different counter. Philox constructs its pseudo-random outputs by applying a small set of mixed arithmetic (multiplication/bitwise) rounds to an input \emph{counter} plus \emph{key}. In particular, \(\mathrm{Philox}\,4\times32\text{-10}\) (often shortened to "Philox-4x32-10”) works on four 32-bit integers at a time:
\[
  \mathbf{S} = (S_0, S_1, S_2, S_3),
  \qquad
  \mathbf{K} = (K_0, K_1).
\]
The four elements \(\{S_0, S_1, S_2, S_3\}\) collectively represent the counter, e.g., \((x_0, x_1, x_2, x_3)\). The two key elements \((K_0, K_1)\) are used to tweak the generator's sequence. A single invocation of Philox-4x32-10 transforms \(\mathbf{S}\) into four new 32-bit outputs after ten rounds of mixing. At each round, the algorithm:
\begin{enumerate}
    \item Multiplies two of the state words by fixed "magic constants” to create partial products.
    \item Takes the high and low 32-bit portions of those 64-bit products.
    \item Incorporates the round key to shuffle the words.
    \item Bumps the key by adding constant increments \((\mathrm{W32A} = 0x9E3779B9 \text{ and } \mathrm{W32B} = 0xBB67AE85)\).
\end{enumerate}
After ten rounds, the final \((S_0, S_1, S_2, S_3)\) is returned as the pseudo-random block. A new call to Philox increases the counter \(\mathbf{S}\) by one (e.g., \(S_3 \mapsto S_3 + 1\)) and re-enters the same function. The Philox-4x32-10 algorithm is designed so that each blocking call requires a \emph{constant number} of operations, independent of the size of any prior "state.” Specifically, each round involves:
\[
  \mathcal{O}(1)\;\text{ arithmetic operations},
\]
and there are \(\mathrm{R} = 10\) rounds. Thus, each Philox invocation is asymptotically constant time \(\mathcal{O}(\mathrm{R}) = \mathcal{O}(1)\). The total cost to generate 128 bits (4 words \(\times\) 32 bits) is therefore constant time per call.

\section{The 10-round Philox-4x32}
Our implementation follows the standard 10-round approach for generating one block of four 32-bit random words, also called Philox-4x32-10. Let \(M_{\mathrm{A}}=0xD2511F53\), \(M_{\mathrm{B}}=0xCD9E8D57\) be the multipliers, and let \((K_0, K_1)\) be the key which is updated each round by \(\mathrm{W32A}=0x9E3779B9\) and \(\mathrm{W32B}=0xBB67AE85\). The function \(\text{Hi}(\cdot)\) returns the high 32 bits of a 64-bit product, and \(\text{Lo}(\cdot)\) returns the low 32 bits. Because each call produces four 32-bit pseudo-random words, Philox-4x32-10 is particularly convenient for batched sampling. If only a single 32-bit word is needed, one can still call the function and discard the excess words; however, many applications consume all four outputs (e.g., to produce four floating-point variates).

\begin{algorithm}[ht]
  \caption{Philox-4x32-10}\label{alg:philox}
  \begin{algorithmic}[1]
    %------------------------------------------------------------
    \Require Four 32-bit counters $(S_0,S_1,S_2,S_3)$,
            key $(K_0,K_1)$
    \Ensure  Transformed counters $(S_0,S_1,S_2,S_3)$
    %------------------------------------------------------------
    \Statex
    %--------------------- Philox_Round -------------------------
    \Procedure{Philox\_Round}{$(S_0,S_1,S_2,S_3),\,(K_0,K_1)$}
      \State $P_0 \gets M_{\text{A}}\times S_0$ \Comment{64-bit product}
      \State $P_1 \gets M_{\text{B}}\times S_2$ \Comment{64-bit product}
      \State $T_0 \gets \mathrm{Hi}(P_1)\,\oplus\,S_1\,\oplus\,K_0$
      \State $T_1 \gets \mathrm{Lo}(P_1)$
      \State $T_2 \gets \mathrm{Hi}(P_0)\,\oplus\,S_3\,\oplus\,K_1$
      \State $T_3 \gets \mathrm{Lo}(P_0)$
      \State $K_0 \gets K_0 + \mathrm{W32A}$
      \State $K_1 \gets K_1 + \mathrm{W32B}$
      \State \Return $\bigl((T_0,T_1,T_2,T_3),\,(K_0,K_1)\bigr)$
    \EndProcedure
    %------------------- Philox4x32_10 --------------------------
    \Statex
    \Procedure{Philox4x32\_10}{$(S_0,S_1,S_2,S_3),\,(K_0,K_1)$}
      \For{$i \gets 1$ \textbf{to} 10}
        \State $\bigl(S_0,S_1,S_2,S_3),\,(K_0,K_1) \gets$
               \Call{Philox\_Round}{$(S_0,S_1,S_2,S_3),\,(K_0,K_1)$}
      \EndFor
      \State \Return $(S_0,S_1,S_2,S_3)$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\section{Bitpacking for Probability Sampling}
\label{sec:bitpack-prob-sampling}

It takes exactly one bit to represent the outcome of a Bernoulli trial. When these outcomes are stored naively, each occupies an entire \(8\)-bit byte, so only a fraction \(\tfrac{1}{8}\) of the allocated space carries useful information. Packing indicators into the native machine word of width \(w\) therefore reduces memory consumption by up to a factor of eight. More precisely,
\[
  \text{Memory}_{\text{naive}} \;=\; N \times 8\,\text{bits},
  \qquad
  \text{Memory}_{\text{packed}} \;=\;\Bigl\lceil\tfrac{N}{w}\Bigr\rceil \times w\,\text{bits},
\]
where \(N\) is the number of samples. In typical 64-bit environments we choose \(w = 64\), but the derivation is architecture-agnostic.

\subsection{Integer-threshold sampling.}  Instead of converting each 32-bit random word \(r\) produced by Philox into a floating-point variate, we compare it directly to an \emph{integer threshold}.  Let the target probability be \(p \in [0,1]\).  Define the threshold
\[
   T \;=\; \bigl\lfloor p \times 2^{32} \bigr\rfloor,\qquad 0 \le T \le 2^{32}-1.
\]
Because Philox delivers uniformly distributed 32-bit integers over \(\{0,\dots,2^{32}-1\}\), the event \(r < T\) occurs with probability exactly \(p\) (up to the discretization of the 32-bit grid).  The comparison is therefore sufficient to draw a Bernoulli outcome while avoiding the cost of division and floating-point arithmetic.  Using integer thresholds also guarantees identical behavior across heterogeneous hardware, an essential property for reproducible high-performance simulations.

\subsection{Grouping four comparisons.}  Each invocation of \(\mathrm{Philox\text{-}4\times32\text{-}10}\) yields the four words \(r_0, r_1, r_2, r_3\).  We evaluate the predicate \(r_j < T\) for every index \(j \in \{0,1,2,3\}\) and collect the four resulting bits into a 4-bit block.  The block is inserted into a wider accumulator using bitwise shifts.  Repeating the procedure fills the entire \(w\)-bit container.  If we denote by
\[
   g \;=\; \frac{w}{4}
\]
 the number of 4-bit generations required to populate the container, the overall cost is exactly \(g\) calls to the comparison–pack routine, or \(g\) additional increments of the counter component \(S_3\) in Philox.  No state other than the counter is maintained.

\begin{algorithm}[H]
  \caption{Integer-threshold packing of four Bernoulli outcomes}
  \label{alg:bernoulli_bitpack_int}
  \begin{algorithmic}[1]
    %------------------------------------------------------------
    \Require Probability $p\in[0,1]$; 32-bit words $(r_0,r_1,r_2,r_3)$
    \Ensure 4-bit integer \texttt{bits} containing the four Bernoulli draws
    %------------------------------------------------------------
    \State $T \gets \lfloor p\,2^{32}\rfloor$ \Comment{pre-compute once}
    \State \texttt{bits} $\gets 0$
    \For{$j \gets 0$ \textbf{to} $3$}
      \If{$r_j < T$}
        \State $b_j \gets 1$
      \Else
        \State $b_j \gets 0$
      \EndIf
      \State \texttt{bits} $\gets$ \texttt{bits} $\mid\, (b_j \ll j)$
    \EndFor
    \State \Return \texttt{bits}
  \end{algorithmic}
\end{algorithm}

\subsection{Assembling a complete bitpack.}  Calling Algorithm~\ref{alg:bernoulli_bitpack_int} successively for $g$ generations yields a full \(w\)-bit word whose $k$-th bit encodes the outcome of the $k$-th Bernoulli trial, ordered least-significant first.  The procedure is branch-free except for the threshold comparison and operates in $\mathcal{O}(g)$ time.  Because $g$ is fixed by the word size, the complexity is effectively constant per stored word, and the memory savings are realized without sacrificing statistical quality or portability.

% -----------------------------------------------------------------------------
\section{Counter Assignment Across the ND-Range}
\label{subsec:counter_assignment}

Let $(i_x,i_y,i_z)\in[0,G_x)\times[0,G_y)\times[0,G_z)$ denote the global id of a work-item in the basic-event kernel and let $t\in\{0,\dots,T-1\}$ be the Monte-Carlo iteration index.  A collision-free family of Philox counters is obtained via
\[
   \mathbf{C}(i_x,i_y,i_z,t)
   \;=\;
   \bigl(i_{x}+1,\, i_{z}+1,\, i_{y}+1,\, (t+1)\ll 6\bigr),
\]
where the six vacated least-significant bits of the fourth word are reserved for intra-kernel increments.  The mapping is bijective onto
\[
   \{1,\dots,V\}\times\{1,\dots,P\}\times\{1,\dots,B\}\times\{1,\dots,2^{6}\},
\]
guaranteeing independent pseudo-random streams for every work-item without synchronization or shared state.